/*
 * Copyright 2015 Kakao Corporation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.kakao.hbase.manager.command;

import com.kakao.hbase.common.Args;
import com.kakao.hbase.common.Constant;
import com.kakao.hbase.common.util.DecimalStringSplit;
import com.kakao.hbase.common.util.Util;
import org.apache.commons.codec.DecoderException;
import org.apache.hadoop.hbase.HTableDescriptor;
import org.apache.hadoop.hbase.NotServingRegionException;
import org.apache.hadoop.hbase.TableName;
import org.apache.hadoop.hbase.client.Admin;
import org.apache.hadoop.hbase.client.RegionLocator;
import org.apache.hadoop.hbase.util.Bytes;
import org.apache.hadoop.hbase.util.RegionSplitter;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.*;

@SuppressWarnings("unused")
public class Split implements Command {
    private final Admin admin;
    private final Args args;

    Split(Admin admin, Args args) {
        if (args.getOptionSet().nonOptionArguments().size() < 4) {
            usage();
            throw new IllegalArgumentException(Args.INVALID_ARGUMENTS);
        }

        if (args.getTableNamePattern().equals(Args.ALL_TABLES))
            throw new IllegalArgumentException(Args.INVALID_ARGUMENTS);

        this.admin = admin;
        this.args = args;
    }

    public static String usage() {
        return "Split table with the given information.\n"
                + "usage: " + Split.class.getSimpleName().toLowerCase()
                + " <zookeeper quorum> <table regex> <action> [options]\n"
                + "  actions:\n"
                + "    file <input file name>: Input file that is generated by exportkeys command.\n"
                + "    rule <rule name>: Split table into the target number of regions with a rule.\n"
                + "  rule names:\n"
                + "    hexString_up <#regions>: Split with the uniformly distributed upper case hexadecimal string values.\n"
                + "    hexString_down <#regions>: Split with the uniformly distributed down case hexadecimal string values.\n"
                + "    decimalString <#regions> <#cardinality>: Split with the uniformly distributed decimal string values.\n"
                + "    uniform <#regions>: Split with the keys are approximately uniform random bytes.\n"
                + Args.commonUsage();
    }

    private static Set<TableName> tableSet(Admin admin, Args args) throws IOException {
        Set<TableName> tableSet = new HashSet<>();
        HTableDescriptor[] hTableDescriptors = admin.listTables(args.getTableNamePattern());
        for (HTableDescriptor hTableDescriptor : hTableDescriptors) {
            tableSet.add(hTableDescriptor.getTableName());
        }
        return tableSet;
    }

    @Override
    public void run() throws IOException, DecoderException {
        String action = ((String) args.getOptionSet().nonOptionArguments().get(2)).toLowerCase();
        SplitAction splitAction = SplitAction.valueOf(action);
        Set<TableName> tableSet = tableSet(admin, args);
        Map<TableName, List<byte[]>> splitMap = splitAction.split(tableSet, args);

        if (!args.isForceProceed() && !Util.askProceed()) return;

        for (Map.Entry<TableName, List<byte[]>> entry : splitMap.entrySet()) {
            TableName tableName = entry.getKey();
            try (RegionLocator rl = admin.getConnection().getRegionLocator(tableName)) {
                for (byte[] splitPoint : entry.getValue()) {
                    System.out.print("splitting - " + tableName + " - " + Bytes.toStringBinary(splitPoint));
                    try {
                        for (int i = 0; i < Constant.TRY_MAX; i++) {
                            try {
                                split(rl, splitPoint);
                                break;
                            } catch (NotServingRegionException e) {
                                Thread.sleep(Constant.WAIT_INTERVAL_MS);
                            }
                            if (i == Constant.TRY_MAX - 1)
                                throw new RuntimeException("Splitting is not finished in " + (Constant.TRY_MAX * Constant.WAIT_INTERVAL_MS / 1000) + " seconds.");
                        }
                    } catch (IOException e) {
                        if (!e.getMessage().contains("should not give a splitkey which equals to startkey")) throw e;
                        System.out.println(" - SKIPPING");
                        continue;
                    }
                    System.out.println(" - OK");
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    private void split(RegionLocator rl, byte[] splitPoint) throws IOException, InterruptedException {
        int regionCountPrev = rl.getAllRegionLocations().size();
        admin.split(rl.getName(), splitPoint);
        for (int j = 0; j < Constant.TRY_MAX; j++) {
            int regionCountNow = rl.getAllRegionLocations().size();
            if (regionCountPrev < regionCountNow) {
                break;
            } else {
                Thread.sleep(Constant.WAIT_INTERVAL_MS);
            }
        }
    }

    enum SplitAction {
        file {
            @Override
            public Map<TableName, List<byte[]>> split(Set<TableName> tableSet, Args args) throws IOException {
                Map<TableName, List<byte[]>> splitMap = new HashMap<>();

                String startkeysFileName = (String) args.getOptionSet().nonOptionArguments().get(3);
                for (String splitPointStr : Files.readAllLines(Paths.get(startkeysFileName), Constant.CHARSET)) {
                    String[] split = splitPointStr.split(ExportKeys.DELIMITER);
                    if (split.length == 3) {
                        TableName tableName = TableName.valueOf(split[0]);
                        if (!tableSet.contains(tableName)) continue;

                        String startKeyString = split[1].trim();
                        if (startKeyString.length() > 0) {
                            List<byte[]> splitList = splitMap.get(tableName);
                            if (splitList == null) {
                                splitList = new ArrayList<>();
                                splitMap.put(tableName, splitList);
                            }
                            splitList.add(Bytes.toBytesBinary(startKeyString));
                        }
                    } else {
                        throw new IllegalStateException("File " + startkeysFileName + " contains invalid records.");
                    }
                }

                System.out.println("Table \"" + args.getTableNamePattern() + "\" on \"" + args.getZookeeperQuorum() + "\" will be split by \"" + startkeysFileName + "\" file.");
                return splitMap;
            }
        },
        rule {
            @Override
            public Map<TableName, List<byte[]>> split(Set<TableName> tableSet, Args args) throws IOException, DecoderException {
                Map<TableName, List<byte[]>> splitMap = new HashMap<>();

                for (TableName tableName : tableSet) {
                    String ruleArg = ((String) args.getOptionSet().nonOptionArguments().get(3)).toLowerCase();
                    SplitRule splitRule = SplitRule.valueOf(ruleArg);

                    String numRegionsArg = (String) args.getOptionSet().nonOptionArguments().get(4);
                    int numCardinality = 0;
                    if (args.getOptionSet().nonOptionArguments().size() >= 6)
                        numCardinality = Integer.valueOf((String) args.getOptionSet().nonOptionArguments().get(5));
                    List<byte[]> splitList = splitRule.split(Integer.valueOf(numRegionsArg), numCardinality);
                    splitMap.put(tableName, splitList);

                    System.out.println("Table \"" + tableName + "\" on \"" + args.getZookeeperQuorum() + "\" will be split into " + (splitList.size() + 1) + " regions by " + splitRule.name() + " rule.");
                }

                return splitMap;
            }
        };

        public abstract Map<TableName, List<byte[]>> split(Set<TableName> tableSet, Args args) throws IOException, DecoderException;
    }

    enum SplitRule {
        hexstring_up {
            @Override
            public RegionSplitter.SplitAlgorithm createSplitter(int cardinality) {
                return new RegionSplitter.HexStringSplit();
            }

            @Override
            public List<byte[]> split(int numRegions, int cardinality) {
                List<byte[]> splitPointList = new ArrayList<>();
                for (byte[] splitPoint : super.split(numRegions, cardinality)) {
                    splitPointList.add(Bytes.toString(splitPoint).toUpperCase().getBytes());
                }
                return splitPointList;
            }
        },
        hexstring_down {
            @Override
            public RegionSplitter.SplitAlgorithm createSplitter(int cardinality) {
                return new RegionSplitter.HexStringSplit();
            }
        },
        decimalstring {
            @Override
            public RegionSplitter.SplitAlgorithm createSplitter(int cardinality) {
                return new DecimalStringSplit(cardinality);
            }
        },
        uniform {
            @Override
            public RegionSplitter.SplitAlgorithm createSplitter(int cardinality) {
                return new RegionSplitter.UniformSplit();
            }
        };

        public List<byte[]> split(int numRegions, int cardinality) {
            List<byte[]> splitPointList = new ArrayList<>();
            RegionSplitter.SplitAlgorithm splitter = createSplitter(cardinality);
            Collections.addAll(splitPointList, splitter.split(numRegions));
            return splitPointList;
        }

        public abstract RegionSplitter.SplitAlgorithm createSplitter(int cardinality);
    }
}
